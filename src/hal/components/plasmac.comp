component plasmac;

description
"""
A plasma cutting table control component for use with the linuxcnc master branch.

.I VERSION: 0.66 - 19 Aug 2019

.I SUMMARY:
.br
Not dependent on any particular hardware and should work with any hardware that provides the correct I/O.

No Z axis commands are required in gcode as all required height movements are controlled by this component.

Should scale correctly for both metric and inch configuraions.

Three different operating modes:
..RS 1
.br
0 Use the plasmac.arc-voltage-in input pin for both arc-OK and THC.
.br
1 Use the plasmac.arc-ok-in input pin for arc-OK, use the plasmac.arc-voltage-in input pin for THC.
.br
2 Use the plasmac.arc-ok-in input pin for arc-OK, use the plasmac.move-up and the plasmac.move-down input pins for THC, kerf crossing lockout is disabled.
.RE

A spindle 0 on signal (connected to the plasmac.spindle-on input pin) begins the sequence of:
.RS 1
.br
- set feedhold.
.br
- find top of stock.
.br
- move up to pierce height.
.br
- start torch, retry if unsuccessful until too many attempts.
.br
- wait for pierce delay.
.br
- move to puddle jump height (if enabled).
.br
- release feedhold, X/Y motion begins.
.br
- wait for puddle jump delay (if enabled).
.br
- move down to cutting height.
.br
- use THC (if enabled) to adjust torch height using rules for corner lock and kerf crossing.
.br
- when spindle on is removed, turn torch off after delay.
.br
- move to safe height.
.br
- return to idle state and wait for next cut.
.RE

Turn torch off, pause program and move to safe height then wait for 'resume' or 'stop' if the following occur:
.RS 1
.br
- arc is lost.
.br
- plasmac.float-switch input pin is activated.
.br
- plasmac.breakaway input pin is activated.
.br
- program is paused.
.RE

Turn torch off, move to safe height and stop program if the following occur:
.RS 1
.br
- program is stopped.
.br
- minimum height is reached during THC.
.br
- maximum height is reached during THC.
.RE

Safe height may be reduced if torch height (during THC moves) plus safe height would exceed the maximum height.
.br
The minimum allowed reduced safe height is Pierce Height plus 1mm (0.04").
.br
If safe height is reduced an error message is sent.

Cut height can be adjusted on the fly by adding an offset to the plasmac.height-override input pin.
.br
This offset is added to the THC voltage target to lower or raise the torch.

Target voltage can be selected from:
.RS 1
.br
- a voltage automatically read from the initial cut height.
.br
- the plasmac.cut-volts input pin.
.RE

Paused Motion allows reversing and forwarding along the current segment while paused.
.br
Reverse paused motion can only go back as far as the start of the cut the control point is currently on.
.br
Forward paused motion can continue on through any number of cuts to the end of the gcode program.

Dry Run runs the gcode without starting the torch.

.I CUT FEED RATE
.br
Usage of the plasmac.cut-feed-rate input pin requires specifying #<_hal[plasmac.cut-feed-rate]> in the gcode file:
.br
F#<_hal[plasmac.cut-feed-rate]>

If you want to use different feed rates throughout the file then set the plasmac.cut-feed-rate input pin to 0 which will then use the feed rate from the gcode file.
.br
G1 X2 F100
.br
...
.br
G1 X3 F125
.br

There is an example of how it can be done using automatic material handling in the Gmoccapy sim config.

.I IHS SKIP
.br
If a value is set in skip_ihs_distance the IHS skipping is performed in one of two ways:
.RS 1
.br
- If THC is disabled then skip IHS if start of cut less than skip-ihs-distance from last succesful probe.
.br
- If THC is enabled then skip IHS if start of cut less than skip-ihs-distance from end of last cut.
.RE
This feature is disabled after any error. For example if there is a arc failure while cutting then IHS will be performed regardless of where the cut is.

.I SAFE HEIGHT
.br
If plasmac.safe-height is zero then Z axis maximum limit will be used as the safe height and the safe height reduced error will be disabled.

.I AIR SCRIBE
.br
A spindle 1 on signal (connected to the plasmac.scribe-on input pin) begins a scribing sequence:
.br

.I NOTES
.RS 1
.br
- arc-voltage-in is NOT an analog input, it is a floating point number representing the arc voltage which should be linear. An example would be the velocity output of an encoder. To set it up at zero volts, use the actual value of arc-voltage-in as the value for arc-voltage-offset, then apply a known voltage and set arc-voltage scale to known voltage / arc-voltage-out.
.RE

.I DISCLAIMER
.br
THE AUTHOR OF THIS SOFTWARE ACCEPTS ABSOLUTELY NO LIABILITY FOR ANY HARM OR LOSS RESULTING FROM ITS USE.
.br
IT IS EXTREMELY UNWISE TO RELY ON SOFTWARE ALONE FOR SAFETY.
.br
Any machinery capable of harming persons must have provisions for completely removing power from all motors, etc, before persons enter any danger area.
.br
All machinery must be designed to comply with local and national safety codes, and the author of this software can not, and does not, take any responsibility for such compliance.
.br
All plasmac related software is released under the GPLv2. See the file LICENSE for more details.
""";

/* INPUT PINS */
pin in  float   air_scribe_delay            "delay from scribe arm to scribe start";
pin in  bit     air_scribe_on               "start a new scribe, connect to spindle.1.on";
pin in  float   arc_fail_delay              "arc failure timeout (seconds)";
pin in  float   arc_ok_high                 "maximum voltage level for Arc OK signal [mode 0] (volts)";
pin in  bit     arc_ok_in                   "external arc ok input signal [mode 1 & mode 2]";
pin in  float   arc_ok_low                  "minimum voltage level for Arc OK signal [mode 0] (volts)";
pin in  s32     arc_max_starts              "maximum attempts at starting the arc";
pin in  float   arc_voltage_in              "arc voltage input [mode 0 & mode 1] see Notes above";
pin in  float   arc_voltage_offset          "offset to set arc voltage to 0 at 0 volts";
pin in  float   arc_voltage_scale           "scale to convert arc_voltage input to actual volts";
pin in  float   axis_z_min_limit            "axis z minimum limit, connect to ini.z.min-limit";
pin in  float   axis_z_max_limit            "axis z maximum limit, connect to ini.z.max-limit";
pin in  float   axis_z_position             "current z axis position, connect to joint.N.pos-fb";
pin in  float   axis_x_position             "current x axis position, connect to axis.x.pos-cmd";
pin in  float   axis_y_position             "current y axis position, connect to axis.y.pos-cmd";
pin in  bit     breakaway                   "torch breakaway switch (optional, see float_switch)";
pin in  bit     cornerlock_enable           "enable corner lock";
pin in  float   cornerlock_threshold        "corner lock threshold (% of requested feed rate), speeds below this disable THC";
pin in  float   current_velocity            "current machine velocity , connect to motion.current-vel";
pin in  float   cut_feed_rate               "cut feed rate, set to 0 to use feed rate from gcod file (machine units per minute)";
pin in  float   cut_height                  "cut height (machine units)";
pin in  float   cut_volts                   "cut voltage (volts)";
pin in  bit     external_estop              "external estop input";
pin in  float   feed_reduction              "reduce adaptive feed to this percentage (connect to motion.analog-out-03)";
pin in  float   feed_override               "feed override value from gui (connect to halui.feed-override.value)";
pin in  bit     float_switch                "float switch input (can also act as breakaway if it actuates when torch breaks away)";
pin in  float   float_switch_travel         "float switch travel (machine units)";
pin in  float   height_override             "height override adjustment (volts)";
pin in  float   height_per_volt             "torch height change per volt (machine units)";
pin in  bit     kerfcross_enable            "enable kerf crossing [mode 0 & mode 1]";
pin in  float   kerfcross_override          "kerf crossing threshold override as a percentage";
pin in  float   lowpass_frequency           "lowpass cutoff frequency for arc voltage output";
pin in  s32     mode                        "operating mode";
pin in  bit     move_down                   "external thc down switch [mode 2])";
pin in  bit     move_up                     "external thc up switch [mode 2]";
pin in  bit     multi_tool                  "allows the use of multiple tools";
pin in  float   offset_current              "current z axis offset, connect to axis.z.eoffset";
pin in  bit     ohmic_probe_enable          "ohmic probe enable input";
pin in  float   ohmic_probe_offset          "Z axis offset for ohmic probe (machine units)";
pin in  s32     ohmic_max_attempts          "maximum ohmic probe attempts before fallback to float switch";
pin in  bit     ohmic_probe                 "ohmic probe input";
pin in  bit     ohmic_test                  "test for shorted torch";
pin in  float   paused_motion_speed         "multiplier for speed of motion when paused, from -1 to 1";
pin in  float   pid_d_gain                  "derivative gain input [mode 0 & mode 1]";
pin in  float   pid_i_gain                  "integral gain input [mode 0 & mode 1]";
pin in  float   pid_p_gain                  "proportional gain input [mode 0 & mode 1]";
pin in  float   pierce_delay                "time required to pierce stock (seconds)";
pin in  float   pierce_height               "pierce height (machine units)";
pin in  float   probe_feed_rate             "probe down velocity (machine units per minute)";
pin in  bit     probe_test                  "probe test only";
pin in  float   probe_start_height          "probe starting height";
pin in  bit     program_is_idle             "program is idle, connect to halui.program.is-idle";
pin in  bit     program_is_paused           "program is paused, connect to halui.program.is-paused";
pin in  bit     program_is_running          "program is running, connect to halui.program.is-running";
pin in  float   puddle_jump_delay           "delay move from pierce height to cut height (seconds), leave disconnected if not required";
pin in  float   puddle_jump_height          "puddle jump height (percentage of pierce height), leave disconnected if not required";
pin in  float   requested_velocity          "requested velocity, set by a known requested velocity or connect to motion.requested-vel";
pin in  float   restart_delay               "time from arc failure till next restart attempt";
pin in  float   safe_height                 "requested safe traverse height (machine units)";
pin in  float   setup_feed_rate             "feed rate for moves to pierce and cut heights (machine units per minute)";
pin in  float   skip_ihs_distance           "skip IHS if less than this distance from last cut";
pin in  bit     spindle_on                  "start a new cut, connect to spindle.0.on";
pin in  bit     thc_enable                  "enable/disable thc and set the IHS skip type";
pin in  bit     thc_disable                 "thc disable";
pin in  float   thc_delay                   "delay from start of cut to THC enable (seconds)";
pin in  float   thc_feed_rate               "maximum feed rate for thc (machine units per minute)";
pin in  float   thc_threshold               "thc threshold (volts), changes below this have no effect";
pin in  bit     torch_enable                "enable torch";
pin in  bit     torch_off                   "turn torch off";
pin in  float   torch_off_delay             "time delay to turn torch off (seconds)";
pin in  bit     torch_pulse_start           "torch pulse start";
pin in  float   torch_pulse_time            "torch pulse time (seconds)";
pin in  float   units_per_mm                "for scale calcs, connect to halui.machine.units-per-mm";
pin in  bit     use_auto_volts              "use calculated voltage for thc baseline";

/* OUTPUT PINS */
pin out float   adaptive_feed               "for reverse-run, connect to motion.adaptive-feed";
pin out bit     air_scribe_arm              "arm the air scribe";
pin out bit     air_scribe_start            "start the air scribe";
pin out bit     arc_ok_out                  "arc ok output";
pin out float   arc_voltage_out             "arc voltage output [mode 0 & mode 1]";
pin out bit     cornerlock_is_locked        "corner locked indicator";
pin out float   cut_length                  "length of current cut job";
pin out float   cut_time                    "time of current cut job";
pin out bit     feed_hold                   "feed hold, connect to motion.feed_hold";
pin out bit     kerfcross_is_locked         "kerf crossing locked indicator [mode 0 & mode 1]";
pin out bit     led_down                    "thc move down indicator";
pin out bit     led_up                      "thc move up indicator";
pin out s32     offset_counts               "number of counts to offset, connect to axis.z.eoffset-counts";
pin out bit     offset_enable               "enable offsets, connect to axis.z.eoffset-enable";
pin out float   offset_scale                "offset scale, connect to axis.z.eoffset-scale";
pin out bit     ohmic_enable                "on only while probing";
pin out s32     pierce_count                "number of pierce attempts";
pin out bit     program_pause               "pause the current program, connect to halui.program.pause";
pin out bit     program_resume              "resume the currently paused program, connect to halui.program.resume";
pin out bit     program_run                 "run the currently loaded program, connect to halui.program.run";
pin out bit     program_stop                "stop current program, connect to halui.program.stop";
pin out bit     safe_height_is_limited      "safe height is limited indicator";
pin out s32     state_out                   "current state output";
pin out bit     thc_enabled                 "thc is enabled";
pin out bit     torch_on                    "turn torch on, connect to your torch on input";

/* VARIABLES */
variable bool   air_scribe_pause;           /* air-scribe pause flag */
variable float  air_scribe_timer;           /* air-scribe timer */
variable int    arc_starts;                 /* number of attempts to start torch */
variable float  arc_fail_timer;             /* arc failure timer */
variable float  arc_voltage;                /* calculated arc voltage before lowpass filter*/
variable float  axis_x_finish;              /* axis x position at end of cut */
variable float  axis_x_start;               /* axis x position at start of cut */
variable float  axis_y_finish;              /* axis y position at end of cut */
variable float  axis_y_start;               /* axis y position at start of cut */
variable int    count;                      /* for counting */
variable int    cut_height_first;           /* cut height at start of cut */
variable int    cut_height_last;            /* cut height at end of cut */
variable float  cut_offset;                 /* offset from last cut end to this cut start */
variable bool   cut_started;                /* cut has started */
variable int    cut_target;                 /* cut height target offset */
variable bool   error_message;              /* 1 if error message has been sent */
variable bool   first_cut_finished;         /* first cut is complete */
variable bool   float_detected;             /* float switch detected */
variable int    height_ovr_counts;          /* number of counts to change height via override */
variable float  height_ovr_old;             /* old height override value */
variable bool   initialized;                /* initialization flag */
variable float  kerf_ratio;                 /* kerf crossing height to distance ratio */
variable float  kerf_threshold;             /* kerf crossing threshold voltage */
variable float  last_arc_voltage;           /* last sensed arc voltage */
variable int    offset_datum;               /* datum for safe height calcs */
variable int    offset_min;                 /* minimum allowed offset */
variable int    offset_max;                 /* maximum allowed offset */
variable int    ohmic_attempts;             /* current ohmic probe attempts */
variable bool   ohmic_detected;             /* true if ohmic probe detected */
variable int    setup_velocity;             /* velocity for setup moves */
variable bool   paused_motion;              /* paused motion flag */
variable float  paused_motion_timer;        /* minimum run timer for paused motion */
variable float  pid_error_now;              /* current error for pid calcs */
variable float  pid_error_old;              /* old error for pid calcs */
variable float  pid_output;                 /* calculated pid output value */
variable float  pierce_timer;               /* pierce delay timer */
variable int    pierce_target;              /* pierce height target offset */
variable int    probe_force;                /* extra movement of probe after first contact */
variable int    probe_force_val;            /* distance for probe_force */
variable bool   probe_inhibit;              /* inhibit probing */
variable int    probe_offset;               /* offset for active probe */
variable bool   probe_required = 1;         /* a probe sequence is required */
variable int    probe_start_target;         /* probe start height target */
variable bool   probe_testing;              /* probe test active */
variable int    probe_velocity;             /* probe down velocity */
variable int    puddle_jump_percent;        /* puddle jump height as percentage of pierce height */
variable int    puddle_jump_target;         /* puddle jump height target offset */
variable float  puddle_jump_timer;          /* puddle jump delay timer */
variable float  requested_feed_rate;        /* requested feed rate */
variable float  restart_timer;              /* time between torch on attempts*/
variable int    safe_min;                   /* minimum safe height allowed */
variable int    safe_preferred;             /* preferred safe height offset */
variable int    safe_target;                /* safe height target offset */
variable bool   target_sensed;              /* sensed top of stock */
variable int    target_samples = 6;         /* number of samples for setting target_volts */
variable float  target_total;               /* total voltage of samples for setting target_volts */
variable float  target_volts;               /* target voltage for thc, set by arc voltage at cut height */
variable float  thc_delay_timer;            /* thc delay timer */
variable int    thc_velocity;               /* velocity for thc moves */
variable float  torch_off_timer;            /* arc off delay timer */
variable bool   torch_pulse;                /* torch pulse flag */
variable float  torch_pulse_timer;          /* torch pulse timer */
variable float  velocity_scale;             /* the velocity multipler */
variable int    zero_target;                /* zero height target offset */

/* DEBUGGING PINS */
//pin out s32     stop_type_out;

function _;

author "Phillip A Carter";

license "GPLv2 or greater";

option singleton yes;

;;

#include "rtapi_math.h"

typedef enum{IDLE,
             PROBE_HEIGHT,
             PROBE_DOWN,
             PROBE_UP,
             ZERO_HEIGHT,
             PIERCE_HEIGHT,
             TORCH_ON,
             ARC_OK,
             PIERCE_DELAY,
             PUDDLE_JUMP,
             CUT_HEIGHT,
             CUTTING,
             SAFE_HEIGHT,
             MAX_HEIGHT,
             FINISH,
             TORCHPULSE,
             PAUSED_MOTION,
             OHMIC_TEST,
             PROBE_TEST,
             AIR_SCRIBE,
             DEBUG} state_t;

typedef enum{NONE,
             STOP,
             WAIT,
             PAUSE} stop_type_t;

typedef enum{ZERO,
             UP,
             DOWN} move_direction_t;

typedef enum{FLOAT,
             OHMIC} probe_type_t;

state_t state = IDLE;
stop_type_t stop_type = NONE;
move_direction_t move_direction = ZERO;
probe_type_t probe_type = FLOAT;

FUNCTION(_) {

    /* DEBUGGING STUFF */
//    stop_type_out = stop_type;

    /* do these first run only */
    if(!initialized && units_per_mm){
        offset_scale = units_per_mm * fperiod;
        velocity_scale = 1 / units_per_mm / 60;
        offset_enable = TRUE;
        adaptive_feed = 1;
        initialized = TRUE;
        probe_force_val = 0.125 * units_per_mm / offset_scale;
    }

    /* output the current state */
    state_out = state;

    /* convert feed rates to velocity */
    setup_velocity = setup_feed_rate * velocity_scale;
    if(probe_feed_rate < setup_feed_rate){
        probe_velocity = probe_feed_rate * velocity_scale;
    }else{
        probe_velocity = setup_velocity;
    }
    if(mode == 2){
        thc_velocity = thc_feed_rate * velocity_scale * pid_p_gain / 100;
    }else{
        thc_velocity = thc_feed_rate * velocity_scale;
    }
    if(thc_velocity < 1){
        thc_velocity = 1;
    }

    /* turn torch off if torch off timer completed */
    if(torch_off_timer > 0){
        torch_off_timer -= fperiod;
        if(torch_off_timer <= 0){
            torch_on = FALSE;
            torch_off_timer = 0;
        }
    }

    /* turn torch off from external input */
    if(torch_off){
        torch_on = FALSE;
    }

    /* set THC state*/
    thc_enabled = (thc_enable && !thc_disable ? 1:0);

    /* set ohmic probe state */
    ohmic_detected = ohmic_probe && ohmic_probe_enable;

    /* set adaptive feed reduction if no paused motion */
    if(state != PAUSED_MOTION){
        if(feed_reduction < 10 && state == CUTTING){
            adaptive_feed = 1;
        }else if(feed_reduction < 100 && state == CUTTING){
            adaptive_feed = feed_reduction * 0.01;
        }else{
            adaptive_feed = 1;
        }
    }

    /* check for an abort */
    /* or for a pause or wait while active */
    if(!probe_test && (external_estop || program_is_idle) && cut_started && !program_run){
        torch_on = FALSE;
        stop_type = STOP;
        program_stop = TRUE;
        cut_started = FALSE;
        probe_required = TRUE;
        axis_x_finish = 0;
        axis_y_finish = 0;
        state = MAX_HEIGHT;
    }else if(!probe_test && state > IDLE && state < SAFE_HEIGHT && stop_type == NONE && cut_started){
        if(program_is_paused){
            torch_on = FALSE;
            stop_type = PAUSE;
            probe_required = TRUE;
            state = MAX_HEIGHT;
        }else if(!spindle_on){
            if(torch_off_delay > 0 && !torch_off){
                torch_off_timer = torch_off_delay;
            }else{
                torch_on = FALSE;
            }
            stop_type = WAIT;
            if(thc_enabled && ((!use_auto_volts || (use_auto_volts && target_volts)) || !torch_enable)){
                axis_x_finish = axis_x_position;
                axis_y_finish = axis_y_position;
            }else{
                axis_x_finish = 0;
                axis_y_finish = 0;
            }
            state = SAFE_HEIGHT;
        }else if(breakaway){
            torch_on = FALSE;
            program_pause = TRUE;
            stop_type = PAUSE;
            probe_required = TRUE;
            rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch activated\n"
                                          "program is paused.");
            probe_inhibit = TRUE;
            state = MAX_HEIGHT;
        }else if(state > PIERCE_HEIGHT && float_switch){
            torch_on = FALSE;
            program_pause = TRUE;
            stop_type = PAUSE;
            probe_required = TRUE;
            rtapi_print_msg(RTAPI_MSG_ERR,"float switch activated\n"
                                          "program is paused.");
            probe_inhibit = TRUE;
            state = MAX_HEIGHT;
        }else if(state > PIERCE_HEIGHT && ohmic_detected){
            torch_on = FALSE;
            program_pause = TRUE;
            stop_type = PAUSE;
            probe_required = TRUE;
            rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe activated\n"
                                          "program is paused.");
            probe_inhibit = TRUE;
            state = MAX_HEIGHT;
        }else if(state > ARC_OK && !arc_ok_out && torch_enable && !torch_off){ ;
            torch_on = FALSE;
            program_pause = TRUE;
            stop_type = PAUSE;
            probe_required = TRUE;
            rtapi_print_msg(RTAPI_MSG_ERR,"valid arc lost\n"
                                          "program is paused.");
            state = MAX_HEIGHT;
        }
    }

    /* calculate arc voltage */
    arc_voltage = (arc_voltage_in - arc_voltage_offset) * arc_voltage_scale;
    if(lowpass_frequency){
        arc_voltage_out += (arc_voltage - arc_voltage_out) * (1 - pow(2.71828, -(2 * M_PI * lowpass_frequency) * fperiod));
    }else{
        arc_voltage_out = arc_voltage;
    }

    /* set arc ok from either arc ok input of from actual arc voltage
     * if using arc ok input, set arc_ok_low_in and/or arc_ok_high_in to 0 */
    if(mode > 0){
        arc_ok_out = arc_ok_in;
    }else if(arc_voltage_out >= arc_ok_low && arc_voltage_out <= arc_ok_high){
        arc_ok_out = TRUE;
    }else{
        arc_ok_out = FALSE;
    }

    /* reset program states */
    if(program_is_idle){
        program_stop = FALSE;
        program_resume = FALSE;
    }else if(program_is_paused){
        program_pause = FALSE;
    }else if(program_is_running){
        program_run = FALSE;
        program_resume = FALSE;
    }

    /* if puddlejump height is 0 then set it to 100 */
    if(puddle_jump_height == 0){
        puddle_jump_percent = 100;
    }else{
        puddle_jump_percent = puddle_jump_height;
    }

/* state machine */
    switch(state){
        case IDLE:
            if(probe_inhibit && !float_switch && !breakaway && !ohmic_detected){
                probe_inhibit = FALSE;
            }else if(!probe_inhibit){
                /* if we get a paused motion request and we are paused */
                if(paused_motion_speed && stop_type == PAUSE){
                    state = PAUSED_MOTION;
                /* if we get a torch start request and we are stopped or waiting for a restart */
                }else if((((spindle_on && !air_scribe_on && multi_tool) || (spindle_on && !multi_tool)) || probe_test) && (stop_type == NONE || stop_type == WAIT)){
                    feed_hold = TRUE;
                    stop_type = NONE;
                    //touchdown = FALSE;
                    if(!probe_test){
                        cut_started = TRUE;
                    }else{
                        probe_testing = TRUE;
                    }
                    if(!thc_enabled && first_cut_finished){
                        cut_offset = sqrt(pow(axis_x_start - axis_x_position, 2) + pow(axis_y_start - axis_y_position, 2));
                    }else if((axis_x_finish || axis_y_finish) && first_cut_finished){
                        cut_offset = sqrt(pow(axis_x_finish - axis_x_position, 2) + pow(axis_y_finish - axis_y_position, 2));
                        axis_x_finish = 0;
                        axis_y_finish = 0;
                    }
                    if(cut_offset && cut_offset < skip_ihs_distance && !probe_required){
                        if(thc_enabled){
                            cut_target = cut_target + cut_height_last - cut_height_first;
                            pierce_target = pierce_target + cut_height_last - cut_height_first;
                            puddle_jump_target = puddle_jump_target + cut_height_last - cut_height_first;
                            cut_height_first = cut_height_last;
                        }
                        cut_offset = 0;
                        state = PIERCE_HEIGHT;
                    }else{
                        ohmic_enable = TRUE;
                        if(ohmic_detected && !probe_inhibit){
                            ohmic_enable = FALSE;
                            probe_inhibit = TRUE;
                            if(probe_testing){
                                rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected before moving to probe height.");
                            }else{
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected before moving to probe height.\n"
                                                              "program is paused.");
                            }
                        }else if(float_switch && !probe_inhibit){
                            probe_inhibit = TRUE;
                            if(probe_testing){
                                rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected before moving to probe height.");
                            }else{
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected before moving to probe height.\n"
                                                              "program is paused.");
                            }
                        }else if(breakaway && !probe_inhibit){
                            probe_inhibit = TRUE;
                            if(probe_testing){
                                rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected before moving to probe height.");
                            }else{
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected before moving to probe height.\n"
                                                              "program is paused.");
                            }
                        }else if (!program_is_paused){
                            if(!first_cut_finished){
                                if(probe_start_height){
                                    probe_start_target = offset_counts - ((axis_z_position - axis_z_min_limit - probe_start_height) / offset_scale);
                                }else{
                                    probe_start_target = offset_counts;
                                }
                            }
                            cut_offset = 0;
                            state = PROBE_HEIGHT;
                        }
                    }
                /* if we get a resume request and we are paused */
                }else if(!program_is_paused && stop_type == PAUSE){
                    feed_hold = TRUE;
                    stop_type = NONE;
                /* if torch pulse requested */
                }else if(torch_pulse_start){
                    feed_hold = TRUE;
                    state = TORCHPULSE;
                /* if ohmic probe shorted test requested */
                }else if(ohmic_test){
                    feed_hold = TRUE;
                    ohmic_enable = TRUE;
                    state = OHMIC_TEST;
                /* if we get a air-scribe start request */
                }else if(air_scribe_on && !spindle_on && !probe_test && multi_tool){
                    state = AIR_SCRIBE;
                    air_scribe_timer = air_scribe_delay;
                    air_scribe_pause = FALSE;
                }else if(!cut_started){
                    feed_hold = FALSE;
                }
            }
            break;
        case PROBE_HEIGHT:
            /* move to probe height at setup speed */
            if(probe_testing && !probe_test){
                state = PROBE_TEST;
                break;
            }
            if(float_switch && !float_detected){
                if(probe_testing){
                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected while moving to probe height.");
                    state = PROBE_TEST;
                }else{
                    stop_type = PAUSE;
                    program_pause = TRUE;
                    state = MAX_HEIGHT;
                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected while moving to probe height.\n"
                                                  "program is paused.");
                }
            }else if(ohmic_detected){
                if(probe_testing){
                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected while moving to probe height.");
                    state = PROBE_TEST;
                }else{
                    stop_type = PAUSE;
                    program_pause = TRUE;
                    state = MAX_HEIGHT;
                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected while moving to probe height.\n"
                                                  "program is paused.");
                }
            }else if(offset_counts - setup_velocity > probe_start_target){
                offset_counts -= setup_velocity;
            }else if(offset_counts + setup_velocity < probe_start_target){
                offset_counts += setup_velocity;
            }else if(offset_counts > probe_start_target || offset_counts < probe_start_target){
                offset_counts = probe_start_target;
            }else{
                if(float_detected){
                    if(!float_switch){
                        float_detected = FALSE;
                    }
                }else{
                    state = PROBE_DOWN;
                }
            }
            break;
        case PROBE_DOWN:
            /* probe down to top of stock at probe speed, then push a little further for good contact */
            feed_hold = TRUE;
            if(probe_testing && !probe_test){
                state = PROBE_TEST;
                break;
            }
            if(target_sensed){
                if(probe_force > 0){
                    probe_force -= 21;
                    offset_counts -= probe_velocity;
                }else{
                    target_sensed = FALSE;
                    if(float_switch || ohmic_detected){
                        state = PROBE_UP;
                    }else{
                        rtapi_print_msg(RTAPI_MSG_ERR,"probe trip error while probing.");
                        state = IDLE;
                    }
                }
            }else if(!float_switch && !ohmic_detected){
                if(axis_z_position - (probe_velocity * offset_scale) <= axis_z_min_limit){
                    if(!probe_test){
                        rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while probing down.\n"
                                                      "program is paused.");
                        stop_type = PAUSE;
                        program_pause = TRUE;
                    }else{
                        rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while probe testing.");
                    }
                    state = MAX_HEIGHT;
                }else{
                    offset_counts -= probe_velocity;
                }
            }else if(float_switch && !float_detected){
                if(ohmic_attempts == ohmic_max_attempts){
                    probe_type = FLOAT;
                    target_sensed = TRUE;
                    probe_force = probe_force_val;
                    ohmic_attempts = 0;
                    float_detected = FALSE;
                }else{
                    state = PROBE_HEIGHT;
                    ohmic_attempts += 1;
                    float_detected = TRUE;
                }
            }else if(ohmic_detected){
                probe_type = OHMIC;
                target_sensed = TRUE;
                probe_force = probe_force_val;
                ohmic_attempts = 0;
            }
            break;
        case PROBE_UP:
            /* probe up at minimum speed to find top of stock */
            if(probe_testing && !probe_test){
                state = PROBE_TEST;
                break;
            }
            if(float_switch || ohmic_detected){
                offset_counts += 1;
            }else{
                if(probe_type == OHMIC){
                    probe_offset = ohmic_probe_offset / offset_scale;
                }else{
                    probe_offset = float_switch_travel / offset_scale;
                }
                zero_target = offset_counts + probe_offset;
                cut_target = cut_height_first = offset_datum = offset_counts + probe_offset + (cut_height / offset_scale);
                pierce_target = offset_counts + probe_offset + (pierce_height / offset_scale);
                puddle_jump_target = offset_counts + probe_offset + (pierce_height * (puddle_jump_percent / 100) / offset_scale);
                safe_min = (pierce_height + (1 * units_per_mm)) / offset_scale;
                safe_preferred = safe_height / offset_scale;
                offset_min = offset_counts - ((axis_z_position - axis_z_min_limit) / offset_scale);
                offset_max = offset_counts + (axis_z_max_limit - axis_z_position - (1 * units_per_mm)) / offset_scale;
                if(safe_height == 0){
                    safe_target = offset_max;
                    ohmic_enable = FALSE;
//                    state = ZERO_HEIGHT;
                    state = PIERCE_HEIGHT;
                }else if(offset_counts + safe_min >= offset_max){
                    safe_target = offset_max;
                    rtapi_print_msg(RTAPI_MSG_ERR, "material too high for safe traverse.\n"
                                                   "program is paused.");
                    stop_type = PAUSE;
                    program_pause = TRUE;
                    state = MAX_HEIGHT;
                }else if(offset_counts + safe_preferred >= offset_max && !safe_height_is_limited){
                    rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced.");
                    safe_target = offset_max;
                    safe_height_is_limited = TRUE;
                    ohmic_enable = FALSE;
//                    state = ZERO_HEIGHT;
                    state = PIERCE_HEIGHT;
                }else{
                    safe_target = offset_counts + safe_preferred;
                    ohmic_enable = FALSE;
//                    state = ZERO_HEIGHT;
                    state = PIERCE_HEIGHT;
                }
            }
            break;
        case ZERO_HEIGHT:
            probe_required = FALSE;
            if(probe_testing && !probe_test){
                state = PROBE_TEST;
                break;
            }
            if(offset_counts - setup_velocity > zero_target){
                offset_counts -= setup_velocity;
            }else if(offset_counts + setup_velocity < zero_target){
                offset_counts += setup_velocity;
            }else{
                offset_counts = zero_target;
                axis_x_start = axis_x_position;
                axis_y_start = axis_y_position;
                state = PIERCE_HEIGHT;
            }
            break;
        case PIERCE_HEIGHT:
            /* move up to pierce height */
            if(probe_testing && !probe_test){
                state = PROBE_TEST;
                break;
            }
            if(pierce_height && cut_height && (use_auto_volts || (!use_auto_volts && cut_volts))){
                feed_hold = TRUE;
                if(offset_counts - setup_velocity > pierce_target){
                    offset_counts -= setup_velocity;
                }else if(offset_counts + setup_velocity < pierce_target){
                    offset_counts += setup_velocity;
                }else{
                    offset_counts = pierce_target;
                    arc_starts = 0;
                    if(probe_testing){
                        state = PROBE_TEST;
                    }else if(!torch_enable){
                        pierce_timer = pierce_delay;
                        state = PIERCE_DELAY;
                    }else if(spindle_on){
                        state = TORCH_ON;
                    }
                }
            }else if(!probe_testing){
                stop_type = PAUSE;
                program_pause = TRUE;
                state = MAX_HEIGHT;
                rtapi_print_msg(RTAPI_MSG_ERR,"invalid pierce height.\n"
                                              "or invalid cut height.\n"
                                              "or invalid cut volts.");
            }
            break;
        case TORCH_ON:
            /* turn torch on and start arc fail timer
             * if too many attempts then turn torch off, pause program and return to idle state */
            feed_hold = TRUE;
            if(arc_starts > arc_max_starts - 1){
                program_pause = TRUE;
                restart_timer = 0;
                if (!error_message){
                    rtapi_print_msg(RTAPI_MSG_ERR,"no arc detected after %d start attempts\nprogram is paused.", arc_max_starts);
                    error_message = 1;
                }
            }else{
                error_message = 0;
                restart_timer -= fperiod;
                if(restart_timer <= 0){
                    restart_timer = 0;
                    arc_fail_timer = arc_fail_delay;
                    if(torch_enable){
                        torch_on = TRUE;
                        pierce_count += 1;
                    }
                    state = ARC_OK;
                }
            }
            break;
        case ARC_OK:
            /* wait for arc ok
             * if timeout occurs turn torch off then return to TORCH_ON for another attempt */
            feed_hold = TRUE;
            arc_fail_timer -= fperiod;
            if(arc_fail_timer <= 0){
                torch_on = FALSE;
                restart_timer = restart_delay;
                arc_starts += 1;
                state = TORCH_ON;
            }else if(arc_ok_out){
                    pierce_timer = pierce_delay;
                    state = PIERCE_DELAY;
            }
            break;
        case PIERCE_DELAY:
            /* wait for arc to pierce stock */
            feed_hold = TRUE;
            if(pierce_timer > 0){
                pierce_timer -= fperiod;
            }else{
                puddle_jump_timer = puddle_jump_delay;
                state = PUDDLE_JUMP;
            }
            break;
        case PUDDLE_JUMP:
            /* move to puddle_jump height */
            feed_hold = TRUE;
            if(offset_counts - setup_velocity > puddle_jump_target){
                offset_counts -= setup_velocity;
            }else if(offset_counts + setup_velocity < puddle_jump_target){
                offset_counts += setup_velocity;
            }else{
                offset_counts = puddle_jump_target;
                count = 0;
                if(puddle_jump_timer > 0){
                    feed_hold = FALSE;
                    puddle_jump_timer -= fperiod;
                }else{
                    puddle_jump_timer = 0;
                    feed_hold = TRUE;
                    state = CUT_HEIGHT;
                }
            }
            break;
        case CUT_HEIGHT:
            /* move to cut height */
            feed_hold = TRUE;
            if(offset_counts - setup_velocity > cut_target){
                offset_counts -= setup_velocity;
            }else if(offset_counts + setup_velocity < cut_target){
                offset_counts += setup_velocity;
            }else{
                offset_counts = cut_target;
                if((int)floor(offset_current / offset_scale) <= cut_target + 1 && 
                   (int)floor(offset_current / offset_scale) >= cut_target - 1){
                    count = 0;
                    /* set feed rate for this cut */
                    if(cut_feed_rate > 0){
                        requested_feed_rate = cut_feed_rate;
                    }else{
                        requested_feed_rate = requested_velocity;
                    }
                    feed_hold = FALSE;
                    thc_delay_timer = thc_delay;
                    state = CUTTING;
                }
            }
            break;
        case CUTTING:
            /* while cutting and it is not a dry run:
             * if thc is enabled then vary the torch height to keep the arc voltage constant
             * if corner lock enabled, only allow THC if current velocity is greater than the threshold percentage of requested velocity
             * if kerf crossing is enabled, only allow THC if the voltage change is less than the threshold voltage (modes 0 & 1 only)
             * adjust torch height and target voltage to suit if height override requested (modes 0 & 1 only)*/
            if(torch_on){
//            if(torch_enable){
                /* thc control by arc voltage */
                if(mode < 2){
                    thc_delay_timer -= fperiod;
                    if(thc_delay_timer <= 0){
                        /* set target voltage */
                        if(target_volts == 0){
                            if(use_auto_volts){
                                /* wait until velocity is at least 99.9% of requested velocity before sampling arc voltage */
                                if(current_velocity * 60 > requested_feed_rate * feed_override * 0.999){
                                    count += 1;
                                    target_total += arc_voltage_out;
                                    if(count == target_samples){
                                        target_volts = target_total / target_samples;
                                        last_arc_voltage = target_volts;
                                        count = 0;
                                        target_total = 0;
                                    }
                                }
                                if(target_volts == 0){
                                    cornerlock_is_locked = TRUE;
                                }else{
                                    cornerlock_is_locked = FALSE;
                                }
                            }else{
                                target_volts = cut_volts;
                            }
                        /* height override setup*/
                        }else if(fabs(height_override - height_ovr_old) > 0.05){
                            height_ovr_counts -= (height_override - height_ovr_old) / 10 * units_per_mm / offset_scale;
                            height_ovr_old = height_override;
                        /* height override z motion */
                        }else if(height_ovr_counts != 0){
                            if((setup_velocity) < height_ovr_counts){
                                offset_counts -= setup_velocity;
                                height_ovr_counts -= setup_velocity;
                            }else{
                                offset_counts -= height_ovr_counts;
                                height_ovr_counts = 0;
                            }
                        /* torch height control */
                        }else if(thc_enabled){
                            /* lock thc if velocity < requested velocity * cornerlock threshold percentage */
                            if(cornerlock_enable){
                                if(current_velocity * 60 < requested_feed_rate * feed_override * cornerlock_threshold * 0.01){
                                    cornerlock_is_locked = TRUE;
                                }else if(cornerlock_is_locked && current_velocity * 60 > requested_feed_rate * feed_override * 0.99){
                                    cornerlock_is_locked = FALSE;
                                }
                            }else{
                                cornerlock_is_locked = FALSE;
                            }
                            /* unlock kerfcross lock if voltage reduced to safe level  */
                            if(kerfcross_is_locked){
//                                if(arc_voltage_out < last_arc_voltage + (kerf_threshold * 0.05)){
                                if(arc_voltage_out < target_volts + (kerf_threshold * 0.5)){
                                    kerfcross_is_locked = FALSE;
                                    last_arc_voltage = arc_voltage_out;
                                }
                            /* set kerfcross lock if voltage change > kerfcross threshold volts */
                            }else if(kerfcross_enable){
                                if(thc_feed_rate < current_velocity * 60){
                                    kerf_ratio = thc_feed_rate / (current_velocity * 60);
                                }else{
                                    kerf_ratio = 1; /* 45 degree ramp */
                                }
                                kerf_threshold = ((kerf_ratio * current_velocity * fperiod) / height_per_volt) * (kerfcross_override * 0.01);
//                                if(arc_voltage_out > last_arc_voltage + kerf_threshold){
                                if(arc_voltage_out > target_volts + kerf_threshold){
                                    kerfcross_is_locked = TRUE;
                                }else{
                                    last_arc_voltage = arc_voltage_out;
                                }
                            }
                            /* do thc if ok to go */
                            if(!cornerlock_is_locked && !kerfcross_is_locked){
                                pid_error_now = (target_volts + height_override - arc_voltage_out) * 0.1;
                                if(fabs(pid_error_now) < fabs(thc_threshold * 0.1)){
                                    pid_error_now = 0;
                                }
                                pid_output = pid_error_now * pid_p_gain;
                                pid_output += pid_error_now * pid_i_gain * fperiod;
                                pid_output += (pid_error_now - pid_error_old) * pid_d_gain / fperiod;
                                pid_error_old = pid_error_now;
                                if(pid_output > thc_velocity){
                                    pid_output = thc_velocity;
                                }else if(pid_output < -thc_velocity){
                                    pid_output = -thc_velocity;
                                }
                                /* if we hit a soft limit during thc*/
                                if(offset_counts + pid_output <= offset_min || offset_counts + pid_output >= offset_max){
                                    torch_on = FALSE;
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    if(offset_counts + pid_output <= offset_min){
                                        rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while THC moving down.\n"
                                                                      "program is paused.");
                                    }else{
                                        rtapi_print_msg(RTAPI_MSG_ERR,"top limit reached while THC moving up.\n"
                                                                      "program is paused.");
                                    }
                                    pid_output = 0;
                                    state = MAX_HEIGHT;

                                }
                                offset_counts += pid_output;
                            }
                        }
                        if(pid_output > 0){
                            led_up = TRUE;
                        }else if((pid_output) < 0){
                            led_down = TRUE;
                        }else{
                            led_down = FALSE;
                            led_up = FALSE;
                        }
                        pid_output = 0;
                    }
                }else{ /* thc control by move-up and move-down inputs (no kerf crossing in this mode) */
                    if(thc_enabled){
                        /* lock thc if velocity < requested velocity * cornerlock threshold percentage */
                        if(cornerlock_enable){
                            if(current_velocity * 60 < requested_feed_rate * feed_override * cornerlock_threshold * 0.01){
                                cornerlock_is_locked = TRUE;
                            }else if(cornerlock_is_locked && current_velocity * 60 > requested_feed_rate * feed_override * 0.99){
                                cornerlock_is_locked = FALSE;
                            }
                        }else{
                            cornerlock_is_locked = FALSE;
                        }
                        if(move_down && !cornerlock_is_locked){
                            if(offset_counts - thc_velocity <= offset_min){
                                torch_on = FALSE;
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while THC moving down.\n"
                                                              "program is paused.");
                                state = MAX_HEIGHT;
                            }else{ /* move down at requested velocity */
                                offset_counts -= thc_velocity;
                                led_down = TRUE;
                            }
                        }else if(move_up && !cornerlock_is_locked){
                            if(offset_counts + thc_velocity + safe_min >= offset_max){
                                torch_on = FALSE;
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR,"top limit reached while THC moving up.\n"
                                                              "program is paused.");
                                state = MAX_HEIGHT;
                            }else{ /* move up at requested velocity */
                                offset_counts += thc_velocity;
                                led_up = TRUE;
                            }
                        }else{
                            led_down = FALSE;
                            led_up = FALSE;
                        }
                    }
                }
                /* check if safe height is below maximium offset */
                if(offset_counts > offset_datum){
                    safe_target += offset_counts - offset_datum;
                    offset_datum = offset_counts;
                    if(safe_target > offset_max){
                        safe_target = offset_max;
                        if(!safe_height_is_limited){
                            safe_height_is_limited = TRUE;
                            rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced.");
                        }
                    }
                }
            }
            cut_height_last = offset_counts;
            cut_length = cut_length + current_velocity * fperiod;
            cut_time = cut_time + fperiod;
            break;
        case SAFE_HEIGHT:
            /* move to safe height */
            feed_hold = TRUE;
            if(!torch_off_timer || !torch_on){
                cornerlock_is_locked = FALSE;
                if(!probe_test){
                    if(offset_counts - setup_velocity > safe_target){
                        offset_counts -= setup_velocity;
                    }else if(offset_counts + setup_velocity < safe_target){
                        offset_counts += setup_velocity;
                    }else{
                        offset_counts = safe_target;
                        if(stop_type == WAIT){
                            feed_hold = FALSE;
                        }
                        first_cut_finished = TRUE;
                        /* do height override here for for remainder of job */
                        height_ovr_old = 0;
                        state = FINISH;
                    }
                }
            }
            break;
        case MAX_HEIGHT:
            /* move to maximum height */
            feed_hold = TRUE;
            cornerlock_is_locked = FALSE;
            if(!probe_test){
                if(offset_counts - setup_velocity > offset_max){
                    offset_counts -= setup_velocity;
                }else if(offset_counts + setup_velocity < offset_max){
                    offset_counts += setup_velocity;
                }else{
                    offset_counts = offset_max;
                    if(stop_type == WAIT){
                        feed_hold = FALSE;
                    }
                    /* do height override here for remainder of job */
                    height_ovr_old = 0;
                    state = FINISH;
                }
            }
            break;
        case FINISH:
            /* clean up and return to idle state */
            target_volts = 0;
            cornerlock_is_locked = FALSE;
            kerfcross_is_locked = FALSE;
            led_down = FALSE;
            led_up = FALSE;
            ohmic_enable = FALSE;
            cut_length = 0;
            cut_time = 0;
            if(stop_type == STOP){
                program_run = FALSE;
                paused_motion = FALSE;
                adaptive_feed = 1;
                if(program_is_idle){
                    first_cut_finished = FALSE;
                    if(offset_counts - setup_velocity > 0){
                        offset_counts -= setup_velocity;
                    }else if(offset_counts + setup_velocity < 0){
                        offset_counts += setup_velocity;
                    }else{
                        offset_counts = 0;
                        stop_type = NONE;
                        safe_height_is_limited = FALSE;
                        cut_started = FALSE;
                        /* do height override here for one cut only */
                        /* height_ovr_old = 0; */
                    }
                }
            }else{
                state = IDLE;
            }
            break;
        case TORCHPULSE:
            /* single pulse the torch on and off */
            if(!torch_pulse){
                torch_pulse_timer = torch_pulse_time;
                if(torch_enable){
                    torch_on = TRUE;
                }
                torch_pulse = TRUE;
            }else{
                if(torch_pulse_timer > 0){
                    torch_pulse_timer -= fperiod;
                }else{
                    torch_on = FALSE;
                    if(!torch_pulse_start){
                        torch_pulse = FALSE;
                        state = IDLE;
                    }
                }
            }
            break;
        case PAUSED_MOTION:
            /* a bit kludgy but we need a timer here for a minimum run
             * time to give the GUI time to poll the status channel */
            if(paused_motion_speed){
                if(!paused_motion){
                    paused_motion_timer = 0.2; /* 0.2 seconds */
                    paused_motion = TRUE;
                    adaptive_feed = paused_motion_speed;
                    feed_hold = FALSE;
                    program_resume = TRUE;
                }else{
                    paused_motion_timer -= fperiod;
                }
            }else{
                paused_motion_timer -= fperiod;
                feed_hold = TRUE;
                program_pause = TRUE;
                if(program_is_paused && paused_motion_timer <= 0){
                    paused_motion = FALSE;
                    adaptive_feed = 1;
                    state = IDLE;
                }
            }
            break;
        case OHMIC_TEST:
            /* wait here until ohmic_test input released */
            if (!ohmic_test){
                ohmic_enable = FALSE;
                state = IDLE;
            }
            break;
        case PROBE_TEST:
            /* wait here until probe_test input released */
            if(!probe_test){
                probe_testing = FALSE;
                if(offset_counts - setup_velocity > 0){
                    offset_counts -= setup_velocity;
                }else if(offset_counts + setup_velocity < 0){
                    offset_counts += setup_velocity;
                }else{
                    offset_counts = 0;
                    state = FINISH;
                }
            }
            break;
        case AIR_SCRIBE:
            if(!program_is_paused && air_scribe_on){
                air_scribe_arm = TRUE;
            }else{
                air_scribe_arm = FALSE;
            }
            if(!program_is_paused && air_scribe_on && !air_scribe_timer && !program_is_idle){
                air_scribe_start = TRUE;
                feed_hold = FALSE;
            }else{
                air_scribe_start = FALSE;
                feed_hold = TRUE;
            }
            if(program_is_paused){
                air_scribe_timer = air_scribe_delay;
            }
            if(!program_is_paused && air_scribe_timer){
                air_scribe_timer -= fperiod;
                if(air_scribe_timer < 0){
                    air_scribe_timer = 0;
                }
            }
            if(!air_scribe_on){
                air_scribe_timer = 0;
                state = IDLE;
            }
            break;
        case DEBUG:
            /* holding state for debugging */
            rtapi_print_msg(RTAPI_MSG_ERR, "I have no idea how we got here...\n");
            break;
    }
}
